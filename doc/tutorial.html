<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>oPDF tutorial &mdash; oPDF 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="oPDF 1.0 documentation" href="index.html" />
    <link rel="next" title="Full API Documentation" href="api.html" />
    <link rel="prev" title="oPDF" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="Full API Documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="oPDF"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">oPDF 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="opdf-tutorial">
<h1>oPDF tutorial<a class="headerlink" href="#opdf-tutorial" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">oPDF</span></code> is a code for modelling the phase space distribution of
steady-state tracers in spherical potentials. For more information,
check the <a class="reference external" href="http://kambrian.github.io/oPDF">website</a>.</p>
<p>Please consult the science paper(<a class="reference external" href="http://arxiv.org/abs/1507.00769">http://arxiv.org/abs/1507.00769</a>) on how
it works.</p>
<p>You can use this tutorial interactively in ipython notebook by running</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>ipython notebook --pylab=inline
</pre></div>
</div>
<p>from the root directory of the oPDF code. This will open your browser,
and you can click <code class="docutils literal"><span class="pre">tutorial.ipynb</span></code> in the opened webpage. If that does
not work, then simply continue reading this document as a webpage. For
the full API documentation, check
<a class="reference external" href="http://kambrian.github.io/oPDF/doc/api">here</a>.</p>
<div class="section" id="getting-started">
<h2>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<div class="section" id="prerequisites">
<h3>prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h3>
<p>The oPDF code depends on the following libraries:</p>
<ul class="simple">
<li>C libraries<ul>
<li><a class="reference external" href="http://www.gnu.org/software/gsl/">GSL</a></li>
<li><a class="reference external" href="http://www.hdfgroup.org/HDF5/">HDF5</a></li>
</ul>
</li>
<li>Python libraries<ul>
<li><a class="reference external" href="https://pypi.python.org/pypi/numpy">numpy</a>,
<a class="reference external" href="https://pypi.python.org/pypi/scipy">scipy</a>,
<a class="reference external" href="https://pypi.python.org/pypi/matplotlib">matplotlib</a></li>
<li><a class="reference external" href="https://pypi.python.org/pypi/iminuit">iminuit</a> (optional, only
needed if you want to do NFW-likelihood fit to the density profile
of dark matter. If you don&#8217;t have it, you need to comment out the
<code class="docutils literal"><span class="pre">iminuit</span></code> related imports in the header of oPDF.py.)</li>
</ul>
</li>
</ul>
<p>You can customize the makefile to specify how to compile and link
against the GSL and HDF5 libraries, by specifying the
<code class="docutils literal"><span class="pre">GSLINC,GSLLIB,HDFINC,HDFLIB</span></code> flags.</p>
</div>
<div class="section" id="build-the-library">
<h3>Build the library<a class="headerlink" href="#build-the-library" title="Permalink to this headline">¶</a></h3>
<p>under the root directory of the code, run</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">make</span>
</pre></div>
</div>
<p>This will generate the library <code class="docutils literal"><span class="pre">liboPDF.so</span></code>, the backend of the python
module. Now you are all set up for the analysis. Open your python shell
in the code directory, and get ready for the modelling. If you want to
get rid of all the <code class="docutils literal"><span class="pre">*.o</span></code> files, you can clean them by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>make clean
</pre></div>
</div>
</div>
<div class="section" id="set-pythonpath">
<h3>Set PYTHONPATH<a class="headerlink" href="#set-pythonpath" title="Permalink to this headline">¶</a></h3>
<p>From now on, you should either work under the current directory, or have
added the <code class="docutils literal"><span class="pre">oPDF</span></code> path to your <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> before using <code class="docutils literal"><span class="pre">oPDF</span></code> in
python. To add the path, do</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>export PYTHONPATH=$PYTHONPATH:$OPDF_DIR
</pre></div>
</div>
<p>in bash, or the following in csh:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>setenv PYTHONPATH ${PYTHONPATH}:$OPDF_DIR
</pre></div>
</div>
<p>. Replace <code class="docutils literal"><span class="pre">$OPDF_DIR</span></code> with the actual root directory of the <code class="docutils literal"><span class="pre">oPDF</span></code>
code above.</p>
</div>
<div class="section" id="prepare-the-data-files">
<h3>Prepare the data files<a class="headerlink" href="#prepare-the-data-files" title="Permalink to this headline">¶</a></h3>
<p>The data files are <a class="reference external" href="http://www.hdfgroup.org/HDF5/">hdf5</a> files
listing the <em>physical</em> positions and velocities of tracer particles,
relative to the position and velocity of the center of the halo. The
code comes with a sample file under data/:</p>
<ul class="simple">
<li>mockhalo.hdf5, a mock stellar halo. The potential is NFW with
<img class="math" src="_images/math/3765ec709412cb6e345903abc98ffebb13258fb1.png" alt="M=133.96\times 10^{10}M_\odot/h"/>, <img class="math" src="_images/math/ac925496c4eb44cdcde263d8440b82821d86a8a0.png" alt="c=16.16"/>, following
the <img class="math" src="_images/math/6400c078e4b85bbc9dc4dc6eaee7e78d354bab62.png" alt="\rho_{\rm vir}=200\rho_{\rm crit}"/> definition.</li>
</ul>
<p>Compulsory datasets in a data file:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x,</span> <span class="pre">shape=[nx3],</span> <span class="pre">datatype=float32</span></code>. The position of each particle.</li>
<li><code class="docutils literal"><span class="pre">v,</span> <span class="pre">shape=[nx3],</span> <span class="pre">datatyep=float32</span></code>. The velocity of each particle.</li>
</ul>
<p>Optional datasets:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">PartMass,</span> <span class="pre">[nx1]</span> <span class="pre">or</span> <span class="pre">1,</span> <span class="pre">float32</span></code>. This is the mass of particles.
Assuming 1 if not specified.</li>
<li><code class="docutils literal"><span class="pre">SubID,</span> <span class="pre">[nx1],</span> <span class="pre">int32</span></code>. This is the subhalo id of each particle, for
examination of the effects of subhaloes during the analysis.</li>
<li><code class="docutils literal"><span class="pre">HaloID,</span> <span class="pre">[nx1],</span> <span class="pre">int32</span></code>. This is the host halo id of each particles.</li>
</ul>
<p>The default system of units are
<img class="math" src="_images/math/eec05c04e655381c43553e84a113d53ae60fbdc5.png" alt="10^{10} M_\odot/h, {\rm kpc}/h, {\rm km/s}"/> for Mass, Length and
Velocity. If the units in the data differ from this system, you can
choose to either update the data so that they follows the default
systems, or change the system of units of oPDF code at run time. See the
units section of this tutorial.</p>
<p><em>Note</em>: to construct a tracer sample for a halo, do not use FoF
particles alone. Instead, make a spherical selection by including all
the particles inside a given radius. These will include FoF particles,
background particles, and particles from other FoFs. FoF selection
should be avoided because it is an arbitrary linking of particles
according to their separations, but not dynamics.</p>
</div>
</div>
<div class="section" id="a-simple-example-fit-the-mock-halo-with-rbinlike">
<h2>A simple example: Fit the mock halo with RBinLike<a class="headerlink" href="#a-simple-example-fit-the-mock-halo-with-rbinlike" title="Permalink to this headline">¶</a></h2>
<div class="section" id="load-the-data">
<h3>Load the data<a class="headerlink" href="#load-the-data" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s import the module first</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">oPDF</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Now the <code class="docutils literal"><span class="pre">oPDFdir</span></code> should have been automatically set to the directory
of the <code class="docutils literal"><span class="pre">oPDF</span></code> code. Let&#8217;s load the sample data</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">datafile</span><span class="o">=</span><span class="n">oPDFdir</span><span class="o">+</span><span class="s2">&quot;/data/mockhalo.hdf5&quot;</span>
<span class="n">FullSample</span><span class="o">=</span><span class="n">Tracer</span><span class="p">(</span><span class="n">datafile</span><span class="p">)</span>
<span class="n">Sample</span><span class="o">=</span><span class="n">FullSample</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>This will load the data into FullSample, and make a subsample of 1000
particles from the FullSample (starting from particle 0 in FullSample).
You may want to do your analysis with the full sample. We extract the
subsample just for illustrution purpose, to speed up the calculation in
this tutorial.</p>
</div>
<div class="section" id="perform-the-fitting">
<h3>Perform the fitting.<a class="headerlink" href="#perform-the-fitting" title="Permalink to this headline">¶</a></h3>
<p>Now let&#8217;s fit the data with the radial binned likelihood estimator with
10 logarithmic radial bins.</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Estimators</span><span class="o">.</span><span class="n">RBinLike</span><span class="o">.</span><span class="n">nbin</span><span class="o">=</span><span class="mi">10</span>
<span class="n">x</span><span class="p">,</span><span class="n">fval</span><span class="p">,</span><span class="n">status</span><span class="o">=</span><span class="n">Sample</span><span class="o">.</span><span class="n">dyn_fit</span><span class="p">(</span><span class="n">Estimators</span><span class="o">.</span><span class="n">RBinLike</span><span class="p">)</span>
<span class="k">print</span> <span class="n">x</span><span class="p">,</span><span class="n">fval</span><span class="p">,</span><span class="n">status</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>[ 100.43937117   26.62967127] 5020.3693017 1
</pre></div>
</div>
<p>In one or two minutes, you will get the results above, where</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> is the best-fitting parameters</li>
<li><code class="docutils literal"><span class="pre">fval</span></code> is the maximum log-likelihood value</li>
<li><code class="docutils literal"><span class="pre">status</span></code> =1 means fitting is successful, =0 means fit failed.</li>
</ul>
<p>That&#8217;s it! You have got the best-fitting
<img class="math" src="_images/math/4a3b66972e8278bc625f194bdd90a7e0209c6b35.png" alt="M=100.44\times10^{10} M_\odot/h"/> and <img class="math" src="_images/math/688b4132d6ed60009c4b01b2a503c4a9d57292ec.png" alt="c=26.63"/>. ###
Estimate significances How does that compare to the real parameters of
<img class="math" src="_images/math/3765ec709412cb6e345903abc98ffebb13258fb1.png" alt="M=133.96\times 10^{10}M_\odot/h"/>, <img class="math" src="_images/math/ac925496c4eb44cdcde263d8440b82821d86a8a0.png" alt="c=16.16"/>? Not too bad,
but let&#8217;s check the likelihood ratio of the two models</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mf">133.96</span><span class="p">,</span><span class="mf">16.16</span><span class="p">]</span>
<span class="n">f0</span><span class="o">=</span><span class="n">Sample</span><span class="o">.</span><span class="n">likelihood</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">Estimators</span><span class="o">.</span><span class="n">RBinLike</span><span class="p">)</span>
<span class="n">likerat</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">fval</span><span class="o">-</span><span class="n">f0</span><span class="p">)</span>
<span class="k">print</span> <span class="n">likerat</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mf">2.78983807112</span>
</pre></div>
</div>
<p>So we got a likelihood ratio of 2.79. How significant is that? According
to Wilks&#8217;s theorem, if the data follows the null model (with the real
parameters), then the likelihood ratio between the best-fit and the null
would follow a <img class="math" src="_images/math/8bd0685e3bf9101859d24cf0e851651f182364c9.png" alt="\chi^2"/> distribution. Since we have two free
parameters, we should compare our likelihood ratio to a
<img class="math" src="_images/math/dffe616e14d6aa250d0af30fa6e7424d2c9a5bd2.png" alt="\chi^2(dof=2)"/> distribution. We can obtain the pval from the
survival function of a <img class="math" src="_images/math/8bd0685e3bf9101859d24cf0e851651f182364c9.png" alt="\chi^2"/> distribution, and convert that to
a Guassian significance level. This is automatically done by the
Chi2Sig() utility function</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myutils</span> <span class="kn">import</span> <span class="n">Chi2Sig</span>
<span class="n">significance</span><span class="o">=</span><span class="n">Chi2Sig</span><span class="p">(</span><span class="n">likerat</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span> <span class="n">significance</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mf">1.15557973053</span>
</pre></div>
</div>
<p>So the best-fitting differs from the real parameters by
<img class="math" src="_images/math/38b9cdf26104f7469838f494f6b91bdd4bb4f4bd.png" alt="\sim1\sigma"/>. It seems we are not very lucky and the fit is only
marginally consistent with the real parameters, but still acceptable.</p>
</div>
<div class="section" id="confidence-contour">
<h3>Confidence Contour<a class="headerlink" href="#confidence-contour" title="Permalink to this headline">¶</a></h3>
<p>Following the same philosophy for the significance levels, we can start
to define confidence contours formed by points that differ from the
best-fitting parameters by a given significance level. This is done by
scanning a likelihood surface and then converting it to a significance
surface. For example, below we scan <img class="math" src="_images/math/ace98e747f555a2c655fa176ba96e7d994fba8a6.png" alt="20\times20"/> grids around the
best-fitting parameters <code class="docutils literal"><span class="pre">x</span></code>, inside a box spanning from
<code class="docutils literal"><span class="pre">log10(x)-dx</span></code> to <code class="docutils literal"><span class="pre">log10(x)+dx</span></code> in each dimension. For the confidence
levels of RBinLike, we can provide the maximum likelihood value that we
obtained above, to save the function from searching for maxlike itself.
Be prepared that the scan can be slow.</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">sig</span><span class="p">,</span><span class="n">like</span><span class="o">=</span><span class="n">Sample</span><span class="o">.</span><span class="n">scan_confidence</span><span class="p">(</span><span class="n">Estimators</span><span class="o">.</span><span class="n">RBinLike</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ngrids</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span> <span class="n">dx</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span> <span class="n">logscale</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">maxlike</span><span class="o">=</span><span class="n">fval</span><span class="p">)</span>
</pre></div>
</div>
<p>The returned <code class="docutils literal"><span class="pre">m,c</span></code> are the grids (1-d vectors) of the scan, and
<code class="docutils literal"><span class="pre">sig,like</span></code> are the significance levels and likelihood values on the
grids (2-d array). Now let&#8217;s plot them in units of the real parameter
values:</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">/</span><span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">sig</span><span class="p">,</span><span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="c1">#1,2,3sigma contours.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;ro&#39;</span><span class="p">)</span> <span class="c1">#the best-fitting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(),</span>  <span class="s1">&#39;k--&#39;</span><span class="p">)</span><span class="c1"># the real parameters</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$M/M_0$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$c/c_0$&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>&lt;matplotlib.text.Text at 0x4585bd0&gt;
</pre></div>
</div>
<img alt="_images/tutorial_16_1.png" src="_images/tutorial_16_1.png" />
</div>
<div class="section" id="phase-images">
<h3>Phase Images<a class="headerlink" href="#phase-images" title="Permalink to this headline">¶</a></h3>
<p>How does the data look in <img class="math" src="_images/math/30619c410588e45fe265de5a10b5a493bd3cef9e.png" alt="(\theta,E,L)"/> space? We can create
images showing the distribution of particles in these coordinates. These
images give a direct visualization of how uniformly the tracer are
distributed along <img class="math" src="_images/math/a9cfbeb8ebee1f365919e147a79e242dcb67ee5d.png" alt="\theta"/>-direction, on different (<img class="math" src="_images/math/1a1124bf69e4213d908ffab32907ed847eee13d3.png" alt="E,L"/>)
orbits. They are quite useful for spotting deviations from
steady-stateness in particular regions in phase space, for example, to
examine local deviations caused by subhaloes.</p>
<p>To avoid having too few particles in each pixel we will start by drawing
a larger sample as NewSample, and then plot the images adopting the real
potential with parameters <code class="docutils literal"><span class="pre">x0</span></code>.</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">NewSample</span><span class="o">=</span><span class="n">FullSample</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20000</span><span class="p">)</span>
</pre></div>
</div>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">NewSample</span><span class="o">.</span><span class="n">phase_image</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">proxy</span><span class="o">=</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Real Potential&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">NewSample</span><span class="o">.</span><span class="n">phase_image</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">proxy</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Real Potential&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>&lt;matplotlib.text.Text at 0x4d04b50&gt;
</pre></div>
</div>
<img alt="_images/tutorial_19_1.png" src="_images/tutorial_19_1.png" />
<p>We can see that the particle distribution is indeed uniform (roughly
given the current resolution) along the <img class="math" src="_images/math/a9cfbeb8ebee1f365919e147a79e242dcb67ee5d.png" alt="\theta"/>-direction,
irrespective of the energy and angular momentum.</p>
</div>
<div class="section" id="ts-profiles">
<h3>TS profiles<a class="headerlink" href="#ts-profiles" title="Permalink to this headline">¶</a></h3>
<p>If you want a more quantitative view of how much deviation there is at
each <img class="math" src="_images/math/cfd13a0f26eb7ef0093319a7669da7dd3771dbac.png" alt="E"/>, <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> or even <img class="math" src="_images/math/2ede365ad144ab396916ec60458da03860803078.png" alt="r"/>, you can plot the mean phase
deviation or AD distance (Test Statistics, or TS) inside different
<img class="math" src="_images/math/d62beb1f2181bb320e8aea6faf1df3ef75d6ed87.png" alt="(E,L,r)"/> bins.</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">proxy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="s1">&#39;rEL&#39;</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">NewSample</span><span class="o">.</span><span class="n">plot_TSprof</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">nbin</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/tutorial_22_0.png" src="_images/tutorial_22_0.png" />
<p>See, the mean phase deviations are within 3<span class="math">\sigma</span> almost
everywhere. Note that the raw mean phase is a standard normal variable
if the tracer is in steady-state under the potential.</p>
</div>
</div>
<div class="section" id="reconstructing-the-mass-profile-with-phase-mark-method">
<h2>Reconstructing the mass profile with Phase-Mark method<a class="headerlink" href="#reconstructing-the-mass-profile-with-phase-mark-method" title="Permalink to this headline">¶</a></h2>
<p>The phase-mark method can reconstruct the mass profile
non-parametrically. The reconstructed profile is typically noisier than
that from parametric fitting, but it&#8217;s non-parametric. Now we
demonstrate how this can be done. First let&#8217;s create some radial bins. A
natural choice is to create bins with equal sample size,</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">xbin</span><span class="o">=</span><span class="n">Sample</span><span class="o">.</span><span class="n">gen_bin</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">nbin</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">equalcount</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>This generates a sequence containing the edges of 3 (<code class="docutils literal"><span class="pre">nbin=3</span></code>) radial
bins. The &#8220;phase marks&#8221;, i.e., the characteristic mass point in each bin
can be found with the <code class="docutils literal"><span class="pre">phase_mass_bin</span></code> function:</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">marks</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Sample</span><span class="o">.</span><span class="n">phase_mass_bin</span><span class="p">(</span><span class="n">xbin</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xbin</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="k">print</span> <span class="n">marks</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>[[  2.57914729   1.00683005   0.49058258   1.36649516   1.           1.
    1.        ]
 [ 10.7295808   34.19465065  23.87852203  41.14360851   1.           1.
    1.        ]
 [ 20.34998195  11.30505188   2.16321596  32.20870383   1.           1.
    1.        ]
 [ 33.25517089  44.79736911  29.35628579  66.65986211   1.           1.
    1.        ]
 [ 64.34329628  68.22149098  60.10142383  77.56745713   1.           1.
    1.        ]]
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">marks</span></code> is now a [nbin, 6] array, where each row contains one
characteristic mass point. The columns are
<code class="docutils literal"><span class="pre">[r,m,ml,mu,flag,flagl,</span> <span class="pre">flagu]</span></code>, where <code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">m</span></code> give the
characteristic radius and characteristic halo mass; <code class="docutils literal"><span class="pre">ml</span></code> and <code class="docutils literal"><span class="pre">mu</span></code>
give the lower and upper bound on <code class="docutils literal"><span class="pre">m</span></code>; <code class="docutils literal"><span class="pre">flag</span></code>, <code class="docutils literal"><span class="pre">flagl</span></code>,<code class="docutils literal"><span class="pre">flagu</span></code>
are convergence flags indicating whether the method has converged when
solving for <code class="docutils literal"><span class="pre">m</span></code>,<code class="docutils literal"><span class="pre">ml</span></code> and <code class="docutils literal"><span class="pre">mu</span></code> respectively (0:no; 1:yes; 2: no
solution to the phase equation, but closest point found). The points we
can trust must at least have <code class="docutils literal"><span class="pre">flag=1</span></code>. If one wants robust error
estimates, then <code class="docutils literal"><span class="pre">flagl=1</span></code> and <code class="docutils literal"><span class="pre">flagu=1</span></code> is also required. All our
data points have flag==1, meaning the fits are all successful, so we do
not need to worry about this below.</p>
<p>We can also fit a functional form to the phase marks. We use the
<code class="docutils literal"><span class="pre">curve_fit</span></code> function from the <code class="docutils literal"><span class="pre">scipy.optimize</span></code> package to do the fit
(need <code class="docutils literal"><span class="pre">scipy</span></code> version <code class="docutils literal"><span class="pre">&gt;0.15.1</span></code> in order to use <code class="docutils literal"><span class="pre">absolute_sigma=1</span></code>
in <code class="docutils literal"><span class="pre">curve_fit</span></code>). We will use the average of the upper and lower
errors, but this is not essential.</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">halofit</span><span class="o">=</span><span class="n">Halo</span><span class="p">(</span><span class="n">HaloTypes</span><span class="o">.</span><span class="n">NFWMC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">halomass</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
  <span class="n">halofit</span><span class="o">.</span><span class="n">set_param</span><span class="p">([</span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">halofit</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="n">err1</span><span class="o">=</span><span class="n">marks</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">marks</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">err2</span><span class="o">=</span><span class="n">marks</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">marks</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">err</span><span class="o">=</span><span class="p">(</span><span class="n">err1</span><span class="o">+</span><span class="n">err2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="n">par</span><span class="p">,</span><span class="n">Cov</span><span class="o">=</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">halomass</span><span class="p">,</span> <span class="n">marks</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">marks</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">absolute_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="s1">&#39;Fitted parameters:&#39;</span><span class="p">,</span> <span class="n">par</span>
<span class="k">print</span> <span class="s1">&#39;Parameter Errors:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Cov</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Fitted parameters: [ 123.24507653   14.92927574]
Parameter Errors: [ 24.43777446   4.36420908]
</pre></div>
</div>
<p>The fitted parameters make sense. Now let&#8217;s plot the marks, the fit to
marks, and compare to the true mass profile:</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">marks</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">marks</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">yerr</span><span class="o">=</span><span class="p">[</span><span class="n">err2</span><span class="p">,</span> <span class="n">err1</span><span class="p">],</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mark&#39;</span><span class="p">)</span>
<span class="n">r</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">halomass</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mark Fit&#39;</span><span class="p">)</span>

<span class="c1">#true mass profile:</span>
<span class="n">halo</span><span class="o">=</span><span class="n">Halo</span><span class="p">()</span>
<span class="n">halo</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="c1">#x0 are the true parameters</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">halo</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;M(&lt;r)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>&lt;matplotlib.text.Text at 0x5217250&gt;
</pre></div>
</div>
<img alt="_images/tutorial_31_1.png" src="_images/tutorial_31_1.png" />
<p>If one is more interested in fitting parametric functions to the
reconstructed profiles, then we recommend to use only 2 radial bins.
Adopting more radial bins lead to finer reconstruction of the profile,
but also leaks some information so the final fit to the marks can be
less accurate. We provide a compact function to combine the steps for
fitting phase marks into a single step. For example, to fit with two
bins, do</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">par2</span><span class="p">,</span><span class="n">Cov2</span><span class="p">,</span><span class="n">marks2</span><span class="o">=</span><span class="n">Sample</span><span class="o">.</span><span class="n">phase_mark_fit</span><span class="p">(</span><span class="n">par0</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">nbin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span> <span class="s1">&#39;mark flags:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">marks2</span><span class="p">[:,</span><span class="mi">4</span><span class="p">:]</span>
<span class="k">print</span> <span class="s1">&#39;Fitted parameters:&#39;</span><span class="p">,</span> <span class="n">par2</span>
<span class="k">print</span> <span class="s1">&#39;Parameter Errors:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Cov2</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>mark flags:
[[ 1.  1.  1.]
 [ 1.  1.  1.]]
Fitted parameters: [ 124.0093333    19.67968255]
Parameter Errors: [ 16.39555491   3.99462691]
</pre></div>
</div>
<p>As you can see, now the parameter errors are smaller. The functional
form of the profile used in the fitting is controlled by the current
<code class="docutils literal"><span class="pre">Sample.halo</span></code>. To use a disired profile, set the halo type <strong>before</strong>
fitting. For example,</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">halo</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">HaloTypes</span><span class="o">.</span><span class="n">NFWMC</span><span class="p">,</span> <span class="n">scales</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>To plot the fit,</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">marks2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">marks2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">yerr</span><span class="o">=</span><span class="p">[</span><span class="n">marks2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">marks2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">marks2</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">marks2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mark&#39;</span><span class="p">)</span>

<span class="n">Sample</span><span class="o">.</span><span class="n">halo</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">par2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Sample</span><span class="o">.</span><span class="n">halo</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mark Fit&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">halo</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;M(&lt;r)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>&lt;matplotlib.text.Text at 0x45946d0&gt;
</pre></div>
</div>
<img alt="_images/tutorial_37_1.png" src="_images/tutorial_37_1.png" />
</div>
<div class="section" id="customizing-the-analysis">
<h2>Customizing the analysis<a class="headerlink" href="#customizing-the-analysis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="estimators">
<h3>Estimators<a class="headerlink" href="#estimators" title="Permalink to this headline">¶</a></h3>
<p>There are several predefined estimators to choose from when you need an
estimator as a parameter. These are listed as members of <code class="docutils literal"><span class="pre">Estimators</span></code>.
In most cases, you can freely choose from the following when an
estimator is required.</p>
<ul class="simple">
<li>Estimators.RBinLike</li>
<li>Estimators.AD</li>
<li>Estimators.MeanPhase</li>
<li>Estimators.MeanPhaseRaw (same as MeanPhase but returns the un-squared
mean phase deviation, so it is a standard normal variable instead of
a chi-square for MeanPhase).</li>
</ul>
<p>For RBinLike, you can also customize the number of radial bins and
whether to bin in linear or log scales. For example, the following will
change the RBinLike to use 20 linear bins.</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Estimators</span><span class="o">.</span><span class="n">RBinLike</span><span class="o">.</span><span class="n">nbin</span><span class="o">=</span><span class="mi">20</span>
<span class="n">Estimators</span><span class="o">.</span><span class="n">RBinLike</span><span class="o">.</span><span class="n">logscale</span><span class="o">=</span><span class="bp">False</span>
</pre></div>
</div>
<p>You can then pass this customized <code class="docutils literal"><span class="pre">Estimators.RBinLike</span></code> to your
likelihood functions. Since the purpose of the binning is purely to
suppress shot noise, a larger number of bins is generally better, as
long as it is not too noisy. On the other hand, when the likelihood
contours appear too irregular, one should try reducing the number of
radial bins to ensure the irregularities are not caused by shot noise.
In our analysis, we have adopted 30 logarithmic bins for an ideal sample
of 1000 particles, and 50 bins for <img class="math" src="_images/math/550df0159f2d6d5bf2a137c8484c0b557cf6edde.png" alt="10^6"/> particles in a realistic
halo, although a bin number as low as 5 could still work.</p>
</div>
<div class="section" id="units">
<h3>units<a class="headerlink" href="#units" title="Permalink to this headline">¶</a></h3>
<p>The system of units is specified in three fundamental units:
Mass[<img class="math" src="_images/math/bc68f05480b157fadfe5636df94ca999feb14e7f.png" alt="M_\odot/h"/>], Length[kpc/<img class="math" src="_images/math/cbb80ad77aa7a5e227d5a46bc44d235284106cfc.png" alt="h"/>], Velocity[km/s]. You
can query the current units with</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Globals</span><span class="o">.</span><span class="n">get_units</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Mass  : 10000000000.0 Msun/h
Length: 1.0 kpc/h
Vel   : 1.0 km/s
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mf">10000000000.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The default units are [<img class="math" src="_images/math/b1666fa286165084e660b7a7f0e7dddd8f389734.png" alt="10^{10} M_\odot/h"/>, kpc/<img class="math" src="_images/math/cbb80ad77aa7a5e227d5a46bc44d235284106cfc.png" alt="h"/>,
km/s]. The oPDF code does not need to know the value of the hubble
constant <img class="math" src="_images/math/cbb80ad77aa7a5e227d5a46bc44d235284106cfc.png" alt="h"/>, as long as the units are correctly specified. It is
the user&#8217;s responsibility to make sure that his/her units are consistent
with his assumed hubble parameter.</p>
<p>If you want to change the system of units, you must do it immediately
after importing the <code class="docutils literal"><span class="pre">oPDF</span></code> module, to avoid inconsistency with units
of previously loaded tracers. For example, if your data is provided in
units of (1e10Msun, kpc, km/s), and you adopt <img class="math" src="_images/math/c0e0a14e7c3300c80e44a70768a1ba74e1721614.png" alt="h=0.73"/> in your
model, then you can set the units like below</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">oPDF</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">h</span><span class="o">=</span><span class="mf">0.73</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">set_units</span><span class="p">(</span><span class="mf">1e10</span><span class="o">*</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, to set them to (<img class="math" src="_images/math/ff4575eae18e30cefeefd3c02c964ec837bdc2b7.png" alt="10^{10}h"/> Msun/<img class="math" src="_images/math/cbb80ad77aa7a5e227d5a46bc44d235284106cfc.png" alt="h"/>,
<img class="math" src="_images/math/cbb80ad77aa7a5e227d5a46bc44d235284106cfc.png" alt="h"/>kpc/<img class="math" src="_images/math/cbb80ad77aa7a5e227d5a46bc44d235284106cfc.png" alt="h"/>, km/s).</p>
<p>The user should only use Globals.set_units() to change the units, which
automatically updates several interal constants related to units. Never
try to change the internal unit variables (e.g.,
Globals.units.MassInMsunh) manually.</p>
</div>
<div class="section" id="cosmology">
<h3>cosmology<a class="headerlink" href="#cosmology" title="Permalink to this headline">¶</a></h3>
<p>The cosmology parameters (<img class="math" src="_images/math/de856b9ac4597201bc8c788149f1e888b3ab4073.png" alt="\Omega_{M0}"/>,
<img class="math" src="_images/math/75e11cee1e19340a6bdc79c30ad1b0654fa5555d.png" alt="\Omega_{\Lambda0}"/>)can be accessed through</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span> <span class="n">Globals</span><span class="o">.</span><span class="n">cosmology</span><span class="o">.</span><span class="n">OmegaM0</span><span class="p">,</span> <span class="n">Globals</span><span class="o">.</span><span class="n">cosmology</span><span class="o">.</span><span class="n">OmegaL0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>0.3 0.7
</pre></div>
</div>
<p>To change the cosmology to (0.25, 0.75), simply do</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Globals</span><span class="o">.</span><span class="n">cosmology</span><span class="o">.</span><span class="n">OmegaM0</span><span class="o">=</span><span class="mf">0.25</span>
<span class="n">Globals</span><span class="o">.</span><span class="n">cosmology</span><span class="o">.</span><span class="n">OmegaL0</span><span class="o">=</span><span class="mf">0.75</span>
</pre></div>
</div>
<p>Again this is advised to be done in the beginning, to avoid
inconsistency in the calculations.</p>
</div>
<div class="section" id="parametrization-of-the-potential">
<h3>parametrization of the potential<a class="headerlink" href="#parametrization-of-the-potential" title="Permalink to this headline">¶</a></h3>
<p>The default parameterization of the potential is a NFW potential with
mass and concentration parameters. You can change the parametrization of
the halo associated with your tracer. For example, if you want to fit
for <img class="math" src="_images/math/98b221d714b31c14edce2f33ab6be0c23164c6f0.png" alt="(\rho_s,r_s)"/> instead of (<img class="math" src="_images/math/2a5d0a03e262a6ebff3d09b9cf9abb3e5f2b6022.png" alt="M,c"/>), then</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">halo</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">halotype</span><span class="o">=</span><span class="n">HaloTypes</span><span class="o">.</span><span class="n">NFWRhosRs</span><span class="p">)</span>
</pre></div>
</div>
<p>Available types are listed as members of the <code class="docutils literal"><span class="pre">HaloTypes</span></code> objects,
including:</p>
<ul class="simple">
<li>HaloTypes.NFWMC: NFW halo parametrized by <img class="math" src="_images/math/ebfe80b31de3ff59c32669ad5a92686427629d21.png" alt="(M,c)"/></li>
<li>HaloTypes.NFWRhosRs: NFW, <img class="math" src="_images/math/98b221d714b31c14edce2f33ab6be0c23164c6f0.png" alt="(\rho_s,r_s)"/></li>
<li>HaloTypes.NFWPotsRs: NFW, (<img class="math" src="_images/math/34f07bb6c51d693ccf6809c687856f428391ae4d.png" alt="\psi_s, r_s"/>), with
<img class="math" src="_images/math/58461b5beddd43d20087fdee4121fb4f49795f49.png" alt="\psi_s=4\pi G\rho_s r_s^2"/>.</li>
<li>HaloTypes.CorePotsRs: Cored Generalized NFW Potential (inner density
slope=0), parametrized by (<img class="math" src="_images/math/80f3e7ed57c124be00759e699b1c8d8beb2fd8ff.png" alt="\psi_s,r_s"/>)</li>
<li>HaloTypes.CoreRhosRs: Cored GNFW, <img class="math" src="_images/math/98b221d714b31c14edce2f33ab6be0c23164c6f0.png" alt="(\rho_s,r_s)"/></li>
<li>HaloTypes.TMPMC: Template profile, <img class="math" src="_images/math/ebfe80b31de3ff59c32669ad5a92686427629d21.png" alt="(M,c)"/> parametrization</li>
<li>HaloTypes.TMPPotScaleRScale: Template,
<img class="math" src="_images/math/7a947bb3fb1e0cc69d0b627a2307ad16cc89e7bf.png" alt="\psi_s/\psi_{s0}, r_s/r_{s0}"/></li>
</ul>
<p>To use template profiles, you have to create them first, in the form of
(<img class="math" src="_images/math/2cb2800f6a05e3f058ab8a355978af183021f8f7.png" alt="r,\psi,\rho(&lt; r)"/>) arrays and the real <img class="math" src="_images/math/5a56f25d5a5f42e0b8d477397dac166f964ba407.png" alt="r_s"/> parameter to
be added to C/TemplateData.h. You need to recompile the C library once
this is done. PotentialProf.py can help you in generating the templates
from DM distributions.</p>
<p>If you use template profiles, you also need to specify the template id,
to tell the code which template in TemplateData.h to use. For example,</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">halo</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">halotype</span><span class="o">=</span><span class="n">HaloTypes</span><span class="o">.</span><span class="n">TMPPotScaleRScale</span><span class="p">,</span> <span class="n">TMPid</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also change the virial definition and redshift of the halo, for
example:</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">halo</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">virtype</span><span class="o">=</span><span class="n">VirTypes</span><span class="o">.</span><span class="n">B200</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>When fitting for the potential, it is always a good choice to adjust the
scales of parameters so that the numerical values of the parameters are
of order 1. oPDF allows you to change the scale of the parameters. The
physical values of the parameters will be the raw parameters times the
scale of parameters. By default, the scales are all set to unity. We can
change them as</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">halo</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">scales</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
<p>Now if we fit the Sample again with the RBinLike estimator, instead of
<code class="docutils literal"><span class="pre">x=[</span> <span class="pre">118.18</span>&nbsp;&nbsp;&nbsp; <span class="pre">19.82]</span></code>, we will get <code class="docutils literal"><span class="pre">x=[1.1818</span>&nbsp;&nbsp;&nbsp; <span class="pre">1.982]</span></code> as the
best fit, but the physical values are not changed.</p>
<div class="section" id="halos">
<h4>Halos<a class="headerlink" href="#halos" title="Permalink to this headline">¶</a></h4>
<p>Each tracer is associated with a halo. You can also work with a seperate
halo object. There are several methods associated with a halo object.
You can set_type(), set_param(), get the mass and potential profiles</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">halo</span><span class="o">=</span><span class="n">Halo</span><span class="p">(</span><span class="n">halotype</span><span class="o">=</span><span class="n">HaloTypes</span><span class="o">.</span><span class="n">NFWMC</span><span class="p">)</span>
<span class="n">halo</span><span class="o">.</span><span class="n">set_param</span><span class="p">([</span><span class="mi">180</span><span class="p">,</span><span class="mi">15</span><span class="p">])</span>
<span class="n">r</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">halo</span><span class="o">.</span><span class="n">mass</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;M(&lt;r)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">halo</span><span class="o">.</span><span class="n">pot</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$-\psi(r)$&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>&lt;matplotlib.text.Text at 0x570efd0&gt;
</pre></div>
</div>
<img alt="_images/tutorial_62_1.png" src="_images/tutorial_62_1.png" />
</div>
</div>
<div class="section" id="selecting-and-cutting">
<h3>selecting and cutting<a class="headerlink" href="#selecting-and-cutting" title="Permalink to this headline">¶</a></h3>
<p>The following line applies a radial cut from 1 to 100 in system unit.
Note it not only selects particles to have <img class="math" src="_images/math/243befebd4375a61835c07606366646562ddbec2.png" alt="1&lt;r&lt;100"/>, but also
sets the radial boundary for the dynamical model, so that only dyanmical
consistency inside the selected radial range is checked.</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">radial_cut</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>This creates a subsample by selecting high angular momentum (L&gt;1e4)
particles:</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">SubSample</span><span class="o">=</span><span class="n">Sample</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">Sample</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">1e4</span><span class="p">)</span>
</pre></div>
</div>
<p>All the particle data can be accessed from the record array Sample.data.
You can do similar selections (and many other operations) on any
available fields of the data (except for radial selection). Have a look
at the datatype or <code class="docutils literal"><span class="pre">Particle_t._fields_</span></code> to see the available fields</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span> <span class="n">Sample</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;haloid&#39;</span><span class="p">,</span> <span class="s1">&#39;subid&#39;</span><span class="p">,</span> <span class="s1">&#39;flag&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;L2&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;vr&#39;</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="s1">&#39;rlim&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note:</p>
<ul class="simple">
<li>The dynamical method tests the radial distribution, so one should
avoid distorting the radial distribution with any radial selection.
One can still apply radial cuts, but should only do this with the
<code class="docutils literal"><span class="pre">Sample.radial_cut(rmin,rmax)</span></code> function.</li>
<li>The <code class="docutils literal"><span class="pre">w</span></code> field is the particle mass in units of the average particle
mass. The average particle mass is <code class="docutils literal"><span class="pre">Sample.mP</span></code>. These are all ones
if no particle mass is given in the datafile.</li>
<li>the <code class="docutils literal"><span class="pre">haloid</span></code> and <code class="docutils literal"><span class="pre">subid</span></code> fields are only filled if you have
<code class="docutils literal"><span class="pre">SubID</span></code> and <code class="docutils literal"><span class="pre">HaloID</span></code> datasets in the datafile when loading.</li>
<li>The <code class="docutils literal"><span class="pre">E</span></code>, <code class="docutils literal"><span class="pre">theta</span></code> and <code class="docutils literal"><span class="pre">rlim</span></code> fields are the energy, phase-angle,
and radial limits (peri and apo-center distances) of the orbits.
These depend on the potential, and are only filled when you have done
some calculation in a halo or have filled them explicitly with the
set_phase() function, e.g.,</li>
</ul>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">set_phase</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="k">print</span> <span class="n">Sample</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span>
<span class="k">print</span> <span class="n">Sample</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">][</span><span class="mi">35</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mf">16450988.2168</span>
<span class="mf">0.809988602192</span>
</pre></div>
</div>
</div>
<div class="section" id="extending-the-code">
<h3>Extending the code<a class="headerlink" href="#extending-the-code" title="Permalink to this headline">¶</a></h3>
<div class="section" id="to-add-new-types-of-potential">
<h4>To add new types of potential:<a class="headerlink" href="#to-add-new-types-of-potential" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>in C/halo.h: add your HaloType identifier in HaloType_t</li>
<li>in C/halo.c:<ul>
<li>write your halo initializer in halo_set_param().</li>
<li>write your potential function in halo_pot()</li>
<li>optionally, write your cumulative mass profile in halo_mass(),
and add any initilization in halo_set_type() if needed.</li>
</ul>
</li>
<li>in oPDF.py:<ul>
<li>add your newly defined halotype to the following line
<code class="docutils literal"><span class="pre">HaloTypes=NamedEnum(...</span></code></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="to-add-new-template-profiles">
<h4>To add new template profiles:<a class="headerlink" href="#to-add-new-template-profiles" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Generate your template in the form of (<img class="math" src="_images/math/2cb2800f6a05e3f058ab8a355978af183021f8f7.png" alt="r,\psi,\rho(&lt; r)"/>)
arrays, and append to <code class="docutils literal"><span class="pre">PotentialTemplate</span></code> in <code class="docutils literal"><span class="pre">C/TemplateData.h</span></code>.</li>
<li>Append the scale radius of the new template to <code class="docutils literal"><span class="pre">TemplateScale</span></code> in
<code class="docutils literal"><span class="pre">C/TemplateData.h</span></code>. This is only used if you want to use <code class="docutils literal"><span class="pre">TMPMC</span></code>
parametrization. In this case the scale radius must be the radius
with respect to which you define the concentration. That is, you must
make sure when you input the real <img class="math" src="_images/math/2a5d0a03e262a6ebff3d09b9cf9abb3e5f2b6022.png" alt="M,c"/> parameters to the
template, and I convert <img class="math" src="_images/math/f0af30c92a973f09f2569ce807e8dd88f26d2b59.png" alt="Rv"/> from <img class="math" src="_images/math/2de38926392ba23abeac75effc66c37a5f5be5fd.png" alt="M"/> and then compare to
this scale radius, I get the real <img class="math" src="_images/math/65868d23a5bfe5b3b2d819386b19c14fa36af134.png" alt="c"/> that you input.</li>
<li><img class="math" src="_images/math/2eca59ef6a923ae3e9ef42ab65fed9f7486510ea.png" alt="\rho(&lt;r)"/> and <img class="math" src="_images/math/5a56f25d5a5f42e0b8d477397dac166f964ba407.png" alt="r_s"/> are only needed if you want to use
<code class="docutils literal"><span class="pre">TMPMC</span></code> parametrization. If you only want to use
<code class="docutils literal"><span class="pre">TMPPotScaleRScale</span></code> parametrization, you can fill <img class="math" src="_images/math/2eca59ef6a923ae3e9ef42ab65fed9f7486510ea.png" alt="\rho(&lt;r)"/>
and <img class="math" src="_images/math/5a56f25d5a5f42e0b8d477397dac166f964ba407.png" alt="r_s"/> with ones or any value.</li>
</ul>
</div>
<div class="section" id="to-add-new-estimators">
<h4>To add new estimators:<a class="headerlink" href="#to-add-new-estimators" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>check <code class="docutils literal"><span class="pre">C/models.c</span></code>.</li>
</ul>
<p>You need to recompile the C library once this is done.
<code class="docutils literal"><span class="pre">PotentialProf.py</span></code> can help you in generating the templates from DM
distributions.</p>
</div>
</div>
</div>
<div class="section" id="additional-features">
<h2>Additional Features<a class="headerlink" href="#additional-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parallel-jobs">
<h3>Parallel jobs<a class="headerlink" href="#parallel-jobs" title="Permalink to this headline">¶</a></h3>
<p>The C backend of oPDF is fully parallelized with <code class="docutils literal"><span class="pre">OpenMP</span></code> for parallel
computation on shared memory machines. To control the number of threads
used, for example to use 16 threads, set the environment variable</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>export OMP_NUM_THREADS=16
</pre></div>
</div>
<p>in bash or</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>setenv OMP_NUM_THREADS 16
</pre></div>
</div>
<p>in csh before running.</p>
<p>When submitting python scripts containing <code class="docutils literal"><span class="pre">oPDF</span></code> calculations to a
batch system on a server, try to submit to a shared memory node and
request more than one CPUs on the node to make use of the parallel
power.</p>
</div>
<div class="section" id="memory-management">
<h3>Memory management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h3>
<p>Each loaded tracer is associated with a memory block in C. If you are
certain you no longer need the tracer, you can clean it to free up
memory. For example,</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">NewSample</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
</pre></div>
</div>
<p>will clear our previously created NewSample. If you know you only need
the tracer for certain operations, you can automate the loading and
cleaning process by using <code class="docutils literal"><span class="pre">with</span></code> statement:</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Tracer</span><span class="p">(</span><span class="n">datafile</span><span class="p">)</span> <span class="k">as</span> <span class="n">TempSample</span><span class="p">:</span>
    <span class="n">NewSample</span><span class="o">=</span><span class="n">TempSample</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>This will load the datafile into <code class="docutils literal"><span class="pre">TempSample</span></code>, create <code class="docutils literal"><span class="pre">NewSample</span></code>
from <code class="docutils literal"><span class="pre">TempSample</span></code>, and clear <code class="docutils literal"><span class="pre">TempSample</span></code> when exiting the <code class="docutils literal"><span class="pre">with</span></code>
block.</p>
</div>
<div class="section" id="bootstrap-sampling">
<h3>Bootstrap sampling<a class="headerlink" href="#bootstrap-sampling" title="Permalink to this headline">¶</a></h3>
<p>To create bootstrap samples (sample with replacement), just sample with
a different seed each time</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">BSSample</span><span class="o">=</span><span class="n">Sample</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="nfw-likelihood">
<h3>NFW-likelihood<a class="headerlink" href="#nfw-likelihood" title="Permalink to this headline">¶</a></h3>
<p>To fit a spatial distribution of particles to an NFW profile (e.g.,
fitting the distribution of dark matter particles in a halo)</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">NFW_fit</span><span class="p">()</span>
</pre></div>
</div>
<pre class="literal-block">
<strong>******************************************************************</strong>
---------------------------------------------------------------------------------------
fval = 6431.376199877737 | nfcn = 85 | ncalls = 85
edm = 7.617539575663999e-07 (Goal: 5e-05) | up = 0.5
---------------------------------------------------------------------------------------
|          Valid |    Valid Param | Accurate Covar |         Posdef |    Made Posdef |
---------------------------------------------------------------------------------------
|           True |           True |           True |           True |          False |
---------------------------------------------------------------------------------------
|     Hesse Fail |        Has Cov |      Above EDM |                |  Reach calllim |
---------------------------------------------------------------------------------------
|          False |           True |          False |             '' |          False |
---------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------
|      | Name  |  Value   | Para Err |   Err-   |   Err+   |  Limit-  |  Limit+  |          |
----------------------------------------------------------------------------------------------
|    0 |     m =  15.61   |  0.558   |          |          |          |          |          |
|    1 |     c =  22.71   |  2.325   |          |          |          |          |          |
----------------------------------------------------------------------------------------------

<strong>******************************************************************</strong>
['m', 'c']
((1.0, -0.15685653025406016), (-0.15685653025406016, 1.0))
       |    0    1
--------------------
m    0 | 1.00 -0.16
c    1 | -0.16 1.00
--------------------
</pre>
<div class="highlight-python"><div class="highlight"><pre><span></span>(({&#39;hesse_failed&#39;: False, &#39;has_reached_call_limit&#39;: False, &#39;has_accurate_covar&#39;: True, &#39;has_posdef_covar&#39;: True, &#39;up&#39;: 0.5, &#39;edm&#39;: 7.617539575663999e-07, &#39;is_valid&#39;: True, &#39;is_above_max_edm&#39;: False, &#39;has_covariance&#39;: True, &#39;has_made_posdef_covar&#39;: False, &#39;has_valid_parameters&#39;: True, &#39;fval&#39;: 6431.376199877737, &#39;nfcn&#39;: 85},
  [{&#39;is_const&#39;: False, &#39;name&#39;: &#39;m&#39;, &#39;has_limits&#39;: False, &#39;value&#39;: 15.611655846563332, &#39;number&#39;: 0L, &#39;has_lower_limit&#39;: False, &#39;upper_limit&#39;: 0.0, &#39;lower_limit&#39;: 0.0, &#39;has_upper_limit&#39;: False, &#39;error&#39;: 0.5579761861939552, &#39;is_fixed&#39;: False},
   {&#39;is_const&#39;: False, &#39;name&#39;: &#39;c&#39;, &#39;has_limits&#39;: False, &#39;value&#39;: 22.711151960080375, &#39;number&#39;: 1L, &#39;has_lower_limit&#39;: False, &#39;upper_limit&#39;: 0.0, &#39;lower_limit&#39;: 0.0, &#39;has_upper_limit&#39;: False, &#39;error&#39;: 2.325172837557389, &#39;is_fixed&#39;: False}]),
 &lt;iminuit._libiminuit.Minuit at 0x53f77b0&gt;)
</pre></div>
</div>
<p>In order for this to make sense, <code class="docutils literal"><span class="pre">Sample</span></code> should be loaded with dark
matter particles of equal particle mass given in <code class="docutils literal"><span class="pre">Sample.mP</span></code>, and the
number density profile times <code class="docutils literal"><span class="pre">Sample.mP</span></code> should give the physical
density profile.</p>
<p>You also need the <a class="reference external" href="https://pypi.python.org/pypi/iminuit">iminuit</a>
python package before you can use this function. If you don&#8217;t have that,
you need to comment out the <code class="docutils literal"><span class="pre">iminuit</span></code> related imports in the header of
<code class="docutils literal"><span class="pre">oPDF.py</span></code>. Please consult the <code class="docutils literal"><span class="pre">iminuit</span></code> documentation for the
<code class="docutils literal"><span class="pre">iminuit</span></code> outputs.</p>
</div>
<div class="section" id="numerical-precision">
<h3>Numerical precision<a class="headerlink" href="#numerical-precision" title="Permalink to this headline">¶</a></h3>
<p>The relative precision for integration of orbits is controlled by
<code class="docutils literal"><span class="pre">Globals.tol.rel</span></code>, which defaults to <code class="docutils literal"><span class="pre">1e-3</span></code>. You can adjust the
numerical accuracy (either for speed or for accuracy concerns), by
assigning to <code class="docutils literal"><span class="pre">Globals.tol.rel</span></code>. For example,</p>
<div class="code ipython2 highlight-python"><div class="highlight"><pre><span></span><span class="n">Globals</span><span class="o">.</span><span class="n">tol</span><span class="o">.</span><span class="n">rel</span><span class="o">=</span><span class="mf">1e-2</span>
</pre></div>
</div>
<p>Typically a value of <code class="docutils literal"><span class="pre">1e-2</span></code> should be sufficient for most applications
such as likelihood inference or phase angle evaluation. Of course, the
lower the precision, the faster the code will be.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">oPDF tutorial</a><ul>
<li><a class="reference internal" href="#getting-started">Getting Started</a><ul>
<li><a class="reference internal" href="#prerequisites">prerequisites</a></li>
<li><a class="reference internal" href="#build-the-library">Build the library</a></li>
<li><a class="reference internal" href="#set-pythonpath">Set PYTHONPATH</a></li>
<li><a class="reference internal" href="#prepare-the-data-files">Prepare the data files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-simple-example-fit-the-mock-halo-with-rbinlike">A simple example: Fit the mock halo with RBinLike</a><ul>
<li><a class="reference internal" href="#load-the-data">Load the data</a></li>
<li><a class="reference internal" href="#perform-the-fitting">Perform the fitting.</a></li>
<li><a class="reference internal" href="#confidence-contour">Confidence Contour</a></li>
<li><a class="reference internal" href="#phase-images">Phase Images</a></li>
<li><a class="reference internal" href="#ts-profiles">TS profiles</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reconstructing-the-mass-profile-with-phase-mark-method">Reconstructing the mass profile with Phase-Mark method</a></li>
<li><a class="reference internal" href="#customizing-the-analysis">Customizing the analysis</a><ul>
<li><a class="reference internal" href="#estimators">Estimators</a></li>
<li><a class="reference internal" href="#units">units</a></li>
<li><a class="reference internal" href="#cosmology">cosmology</a></li>
<li><a class="reference internal" href="#parametrization-of-the-potential">parametrization of the potential</a><ul>
<li><a class="reference internal" href="#halos">Halos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#selecting-and-cutting">selecting and cutting</a></li>
<li><a class="reference internal" href="#extending-the-code">Extending the code</a><ul>
<li><a class="reference internal" href="#to-add-new-types-of-potential">To add new types of potential:</a></li>
<li><a class="reference internal" href="#to-add-new-template-profiles">To add new template profiles:</a></li>
<li><a class="reference internal" href="#to-add-new-estimators">To add new estimators:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#additional-features">Additional Features</a><ul>
<li><a class="reference internal" href="#parallel-jobs">Parallel jobs</a></li>
<li><a class="reference internal" href="#memory-management">Memory management</a></li>
<li><a class="reference internal" href="#bootstrap-sampling">Bootstrap sampling</a></li>
<li><a class="reference internal" href="#nfw-likelihood">NFW-likelihood</a></li>
<li><a class="reference internal" href="#numerical-precision">Numerical precision</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">oPDF</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api.html"
                        title="next chapter">Full API Documentation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tutorial.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="Full API Documentation"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="oPDF"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">oPDF 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Jiaxin Han.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>